using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace NOVisionDesigner.Designer.Windows.RegexEditorWindow
{
    public static class QuickRefItems
    {
        public static List<ReferenceItem> ReferenceItems = new List<ReferenceItem>
        {
            
            
                                                
            //new ReferenceItem() { Title = "Newline", Pattern = "\\n", ExamplePattern = "", ExampleString = "", Description = "Matches a newline character", SubType = "General Tokens" },
            //new ReferenceItem() { Title = "Carriage return", Pattern = "\\r", ExamplePattern = "", ExampleString = "", Description = "Matches a carriage return, unicode character U+2185.", SubType = "General Tokens" },
            //new ReferenceItem() { Title = "Tab", Pattern = "\\t", ExamplePattern = "", ExampleString = "", Description = "Matches a tab character. Historically, tab stops happen every 8 characters.", SubType = "General Tokens" },
            //new ReferenceItem() { Title = "Null character", Pattern = "\\0", ExamplePattern = "", ExampleString = "", Description = "Matches a null character, most often visually represented in unicode using U+2400.", SubType = "General Tokens" },

            //Anchors//
            new ReferenceItem() { Title = "Start of match", Pattern = "\\G", ExamplePattern = "(?: ?\\G|^cats are )((?:silly|cute)(?: |$))", ExampleString = "cats are silly cute and cute", Description = "This will match only at the starting point of the search or the position the previous successful match ended. Useful with the /g flag, or when you are only trying to match after a certain point in a string.", Type = "Anchors"},
            new ReferenceItem() { Title = "Start of string", Pattern = "^", ExamplePattern = "^\\w+", ExampleString = "start of string", Description = "Matches the start of a string without consuming any characters. If /m multiline mode is used, this will also match immediately after a newline character.", SubType = "Common Tokens", Type = "Anchors" },
            new ReferenceItem() { Title = "End of string", Pattern = "$", ExamplePattern = "\\w+$", ExampleString = "end of string", Description = "Matches the end of a string without consuming any characters. If multiline mode is used, this will also match immediately before a newline character.", SubType = "Common Tokens", Type = "Anchors" },
            new ReferenceItem() { Title = "Start of string", Pattern = "\\A", ExamplePattern = "\\A\\w+", ExampleString = "start of string", Description = "Matches the start of a string only. Unlike ^, this is not affected by multiline mode.", Type = "Anchors"},
            new ReferenceItem() { Title = "End of string", Pattern = "\\Z", ExamplePattern = "\\w+\\Z", ExampleString = "end of string", Description = "Matches the end of a string only. Unlike $, this is not affected by multiline mode.", Type = "Anchors"},
            new ReferenceItem() { Title = "Absolute end of string", Pattern = "\\z", ExamplePattern = "\\w+\\z", ExampleString = "absolute end of string", Description = "Matches the end of a string only. Unlike $, this is not affected by multiline mode, and, in contrast to \\Z, will not match before a trailing newline at the end of a string.", Type = "Anchors"},
            new ReferenceItem() { Title = "A word boundary", Pattern = "\\b", ExamplePattern = "d\\b", ExampleString = "word boundaries are odd", Description = "Matches, without consuming any characters, immediately between a character matched by \\w and a character not matched by \\w (in either order). It cannot be used to separate non words from words.", SubType = "Common Tokens", Type = "Anchors"},
            new ReferenceItem() { Title = "Non-word boundary", Pattern = "\\B", ExamplePattern = "r\\B", ExampleString = "regex is really cool", Description = "Matches, without consuming any characters, at the position between two characters matched by \\w.", SubType = "Common Tokens", Type = "Anchors"},

            //Meta Sequences//
            new ReferenceItem() { Title = "Any single character", Pattern = ".", ExamplePattern = ".+", ExampleString = "a b c", Description = "Matches any character other than newline (or including line terminators with the /s flag)", SubType = "Common Tokens", Type="Meta Sequences" },
            new ReferenceItem() { Title = "Alternate - match either a or b", Pattern = "a|b", ExamplePattern = "a|b", ExampleString = "a or b, pick one!", Description = "Matches either what is before the | or what is after it - in this case `a` or `b`.\nYou can use alternates locally as part of a capturing/non-capturing group. For example: /I love (?:cats|dogs) but hate snakes/", SubType = "Common Tokens", Type = "Meta Sequences" },
            new ReferenceItem() { Title = "Any whitespace character", Pattern = "\\s", ExamplePattern = "\\s", ExampleString = "any whitespace character", Description = "Matches any space, tab or newline character.", SubType = "Common Tokens", Type = "Meta Sequences" },
            new ReferenceItem() { Title = "Any non-whitespace character", Pattern = "\\S", ExamplePattern = "\\S+", ExampleString = "any non-whitespace", Description = "Matches anything other than a space, tab or newline.", SubType = "Common Tokens", Type = "Meta Sequences" },
            new ReferenceItem() { Title = "Any digit", Pattern = "\\d", ExamplePattern = "\\d+", ExampleString = "one: 1, two: 2", Description = "Matches any decimal digit. Equivalent to [0-9].", SubType = "Common Tokens", Type = "Meta Sequences" },
            new ReferenceItem() { Title = "Any non-digit", Pattern = "\\D", ExamplePattern = "\\D+", ExampleString = "one: 1, two: 2", Description = "Matches anything other than a decimal/digit.", SubType = "Common Tokens", Type = "Meta Sequences" },
            new ReferenceItem() { Title = "Any word character", Pattern = "\\w", ExamplePattern = "\\w+", ExampleString = "any word character", Description = "Matches any letter, digit or underscore. Equivalent to [a-zA-Z0-9_].", SubType = "Common Tokens", Type = "Meta Sequences" },
            new ReferenceItem() { Title = "Any non-word character", Pattern = "\\W", ExamplePattern = "\\W+", ExampleString = "not.a@word%character", Description = "Matches anything other than a letter, digit or underscore. Equivalent to [^a-zA-Z0-9_]", SubType = "Common Tokens", Type = "Meta Sequences" },
            new ReferenceItem() { Title = "Any Unicode sequences, linebreaks included", Pattern = "\\X", ExamplePattern = "\\X+", ExampleString = "äny únicød3 character", Description = "Matches any valid Unicode sequence, including line breaks. Equivalent to (?:s.).", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Match one data unit", Pattern = "\\C", ExamplePattern = "\\C", ExampleString = "1 unit", Description = "Matches exactly one data unit of input. Can match individual bytes in UTF-8 mode, leading to undefined behaviour if a search starts inside a character.", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Unicodes newlines", Pattern = "\\R", ExamplePattern = "(\\R)", ExampleString = "\nnewline above capture", Description = "Matches any Unicode newline sequence. Equivalent to (?>\\r\\n|\\n|\\x0b|\\f|\\r|\\x85).;", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Match everything but a newline", Pattern = "\\N", ExamplePattern = "\\N+", ExampleString = "non-newline text here\n\nandhere", Description = "Matches any character that is not a newline, the opposite of \\n. Not affected by the single line /s flag.\nEquivalent to (?-s:.)", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Vertical whitespace character", Pattern = "\\v", ExamplePattern = "(\\v)", ExampleString = "line one&vellip;\nlinetwo", Description = "Matches unicode vertical whitespace, considered a character class by the PCRE engine: [\\x{2028}\\n\\r\\x{000B}\\f\\x{2029}\\x{0085}].\nGolang/RE2, Python, and Javascript consider \\v to be just vertical tab (ascii \\x{000B}).\n\\x{2028} is a line separator which can stand for \\r,\\n, \\r\\n, or \\x{0085}.\n\\x{2029} is a paragraph separator (PS) character.\n\\x{0085} is NEL, next line character.", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Negation of \\v", Pattern = "\\V", ExamplePattern = "(\\V+)", ExampleString = "line one\n\nlinetwo", Description = "Matches anything not matched by \\v.\nPCRE equivalent is [^\\x{2028}\\n\\r\\x{000B}\\f\\x{2029}\\x{0085}].\nGolang/RE2, Python, and Javascript equivalent is [^\\x{000B}].", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Horizontal whitespace character", Pattern = "\\h", ExamplePattern = "\\h", ExampleString = "a b c    d", Description = "Matches spaces, tabs, non-breaking/mathematical/ideographic spaces, and so on. Works with Unicode.\nEquivalent to [ \\t\\x{00A0}\\x{1680}\\x{180E}\\x{2000}\\x{2001}\\x{2002}\\x{2003}\\x{2004}\\x{2005}\\x{2006}\\x{2007}\\x{2008}\\x{2009}\\x{200A}\\x{202F}\\x{205F}\\x{3000}].", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Negation of \\h", Pattern = "\\H", ExamplePattern = "\\H+", ExampleString = "a b c d", Description = "Matches any character that is not horizontal whitespace \\h.\nEquivalent to [^ \\t\\x{00A0}\\x{1680}\\x{180E}\\x{2000}\\x{2001}\\x{2002}\\x{2003}\\x{2004}\\x{2005}\\x{2006}\\x{2007}\\x{2008}\\x{2009}\\x{200A}\\x{202F}\\x{205F}\\x{3000}].", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Reset match", Pattern = "\\K", ExamplePattern = "[\\d]+\\K[\\d,]+", ExampleString = "123,456,789", Description = "Sets the given position in the regex as the new start of the match. Nothing preceding \\K will be returned as part of the full match.", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Match subpattern number #", Pattern = "\\#", ExamplePattern = "(.)\\1", ExampleString = "Repeat letters", Description = "Usually referred to as a `backreference`, this will match a repeat of the text matched and captured by the capture group # (number) specified.\nTo reduce ambiguity one may also use \\g#, or \\g{#} where `#` is a digit.", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Unicode property X", Pattern = "\\pX", ExamplePattern = "\\pS", ExampleString = "£ or $ or even ®", Description = "Matches a unicode character with the given property: http://www.fileformat.info/info/unicode/category/index.htm", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Unicode property or script category", Pattern = "\\p{...}", ExamplePattern = "\\p{Armenian}+", ExampleString = "զվարճանք is the word `fun` in Armenian", Description = "Matches a unicode character with the given group of properties or categories:\nhttp://www.fileformat.info/info/unicode/category/index.htm\nhttp://www.regular-expressions.info/unicode.html#category", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Negation of \\pX", Pattern = "\\PX", ExamplePattern = "\\PS+", ExampleString = "£ or $ or even ®", Description = "Matches a unicode character outside of the given property", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Negation of \\p", Pattern = "\\P{...}", ExamplePattern = "\\P{Armenian}", ExampleString = "զվարճանք is the word `fun` in Armenian", Description = "Matches a unicode character that doesn't have any of the given properties.", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Quote; treat as literals", Pattern = "\\Q...\\E", ExamplePattern = "\\Qeverything \\w is ^ literal\\E", ExampleString = "everything \\w is ^ literal", Description = "Any characters between \\Q and \\E, including metacharacters, will be treated as literals.", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Match subpattern `name`", Pattern = "\\k{name}", ExamplePattern = "(?'first'a+) and again (\\k{first})", ExampleString = "aaaa and again aaaa", Description = "Matches the same text a capture group called `name` matched and captured. Alternate notations are \\k<name> and \\k'name'. Valid for .NET.", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Match subpattern `name`", Pattern = "\\k<name>", ExamplePattern = "(?<first>a+) and again (\\k<first>)", ExampleString = "aaaa and again aaaa", Description = "Matches the same text matched and captured by a previously named capture group.", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Match subpattern `name`", Pattern = "\\k'name'", ExamplePattern = "(?'first'a+) and again (\\k'first')", ExampleString = "aaaa and again aaaa", Description = "This is an alternate syntax for \\k<name> or \\k{name}.", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Match nth subpattern", Pattern = "\\gn", ExamplePattern = "(a+) and (\\g1)", ExampleString = "aaaa and again aaaaaaaa", Description = "Matches the text captured by the nth group. n can contain more than one digit, if necessary.\nThis may be useful in order to avoid ambiguity with octal characters.", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Match nth subpattern", Pattern = "\\g{n}", ExamplePattern = "(a+)( and )\\g{1}", ExampleString = "aaa and again aaaaa", Description = "Matches text the nth group matched and captured. `n` represents the capture group number and can positionally refer to past capture groups as well.\n\\g{-2} would be the second previous capture group, for example. \\g{3} would be the third capture group.\nThis notation is useful in avoiding ambiguity with octal characters, or when a literal number needs to be matched immediately after a \\gn reference in the regex.", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Match text the ntn relative previous subpattern matched", Pattern = "\\g{-n}", ExamplePattern = "([a-z]+)( and )\\g{-2}", ExampleString = "aaa and aaaaa", Description = "Matches the same text the nth group prior to \\g{-n} matched and captured.\n\\g{-3} can be used to match the same text the third preceding capture group matched and captured.", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Recurse nth capture group", Pattern = "\\g<n>", ExamplePattern = "([a-z]+) and (\\g<1>)", ExampleString = "a and abc", Description = "Recurse nth capture group. `n` can be positional as well. For example, \\g<-1> stands for the previous capture group, while \\g<+3> would be the third next capture group. Equivalent to \\g'n'", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Recurse nth relative upcoming subpattern", Pattern = "\\g<+n>", ExamplePattern = "\\g<+2>( and )([a-z])", ExampleString = "extra b and c stuff", Description = "Recurse nth capture group ahead of the current position of \\g<+n>. For example, \\g<+2> is the second upcoming capture group.", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Recurse nth capture group", Pattern = "\\g'n'", ExamplePattern = "([a-z]+) and (\\g'1')", ExampleString = "Recurse nth capture group. `n` can be positional as well. For example, \\g'-1' stands for previous capture group, while \\g'3' would be the third capture group. Equivalent to \\g<n>.", Description = "", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Recurse nth relative upcoming subpattern", Pattern = "\\g'+n'", ExamplePattern = "\\g'+2'( and )([a-z])", ExampleString = "extra a and b stuff", Description = "Recurse nth capture group ahead of the current position of \\g'+n'. For example \\g'-2' is the second previous capture group.", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Match previously-named capture group `letter`", Pattern = "\\g{letter}", ExamplePattern = "(?'letter'a) plus (\\g{letter})", ExampleString = "a plus a", Description = "Matches the same text capture group called `letter` matched and captured.", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Recurse named capture group `letter`", Pattern = "\\g<letter>", ExamplePattern = "(?<letter>[a-z]+)( and )(\\g<letter>)", ExampleString = "a and bcd", Description = "Recurse the capture group called `letter`. This is an alternative notation for \\g'letter'", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Recurse named capture group `letter`", Pattern = "\\g'letter'", ExamplePattern = "(?<letter>[a-z]+)( and )(\\g'letter')", ExampleString = "Recurse the capture group called `letter`.", Description = "", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Hex character YY", Pattern = "\\xYY", ExamplePattern = "\\x20", ExampleString = "match all spaces", Description = "Matches the 8-bit character with the given hex value. Unicode Character Table", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Hex character YYYY", Pattern = "\\x{YYYY}", ExamplePattern = "\\x{0025}", ExampleString = "%", Description = "Matches the 16-bit character with the given hex value. Unicode Character Table", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Octal character ddd", Pattern = "\\ddd", ExamplePattern = "\\045", ExampleString = "%", Description = "Matches the 8-bit character with the given octal value. Octal Character Table", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Control character Y", Pattern = "\\cY", ExamplePattern = "\\cI", ExampleString = "horizontal        tab", Description = "Matches ASCII characters typically associated with Control+A through Control+Z: \\x01 through \\x1A. ASCII control characters", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Backspace character", Pattern = "\\b", ExamplePattern = "", ExampleString = "", Description = "Matches the backspace control character. \\b stands for `word boundary` when outside of a character class [...].", Type = "Meta Sequences"},
            new ReferenceItem() { Title = "Makes any character literal", Pattern = "\\", ExamplePattern = "\\\\w", ExampleString = "match \\w literaly", Description = "Converts metacharacters to literal characters, and also allows literal matching of the regex delimiter in use, like `/`.", Type = "Meta Sequences"},
            
            //Quantifiers//
            new ReferenceItem() { Title = "Zero or one of a", Pattern = "a?", ExamplePattern = "ba?", ExampleString = "ba b a", Description = "Matches an `a` character or nothing.", SubType = "Common Tokens",  Type = "Quantifiers" },
            new ReferenceItem() { Title = "Zero or more of a", Pattern = "a*", ExamplePattern = "ba*", ExampleString = "a ba baa aaa ba b", Description = "Matches zero or more consecutive `a` characters.", SubType = "Common Tokens",  Type = "Quantifiers" },
            new ReferenceItem() { Title = "One or more of a", Pattern = "a+", ExamplePattern = "a+", ExampleString = "a aa aaa aaaa bab baab", Description = "Matches one or more consecutive `a` characters.", SubType = "Common Tokens",  Type = "Quantifiers" },
            new ReferenceItem() { Title = "Exactly 3 of a", Pattern = "a{3}", ExamplePattern = "a{3}", ExampleString = "a aa aaa aaaa", Description = "Matches exactly 3 consecutive `a` characters.", SubType = "Common Tokens",  Type = "Quantifiers" },
            new ReferenceItem() { Title = "3 or more of a", Pattern = "a{3,}", ExamplePattern = "a{3,}", ExampleString = "a aa aaa aaaa aaaaaa", Description = "Matches at least 3 consecutive `a` characters.", SubType = "Common Tokens",  Type = "Quantifiers" },
            new ReferenceItem() { Title = "Between 3 and 6 of a", Pattern = "a{3,6}", ExamplePattern = "a{3,6}", ExampleString = "a{3,6} aa aaa aaaa aaaaaaaaaa", Description = "Matches between 3 and 6 (inclusive) consecutive `a` characters.", SubType = "Common Tokens", Type = "Quantifiers"},
            new ReferenceItem() { Title = "Greedy quantifier", Pattern = "a*", ExamplePattern = "a.*a", ExampleString = "greedy can be dangerous at times", Description = "Matches as many characters as possible.", Type = "Quantifiers"},
            new ReferenceItem() { Title = "Lazy quantifier", Pattern = "a*?", ExamplePattern = "r\\w*?", ExampleString = "r re regex", Description = "Matches as few characters as possible.", Type = "Quantifiers"},
            new ReferenceItem() { Title = "Possessive quantifier", Pattern = "a*+", ExamplePattern = "\\d++.", ExampleString = "123", Description = "Matches as many characters as possible; backtracking can't reduce the number of characters matched. Because it is greedy, it will match all the way to the last digit, leaving nothing else for the . to match. Without backtracking, this regex fails to produce a match.", Type = "Quantifiers"},

            //Group Constructs//
            new ReferenceItem() { Title = "Match everything enclosed", Pattern = "(?:...)", ExamplePattern = "match this (?:match that)", ExampleString = "match this match that", Description = "A non-capturing group allows you to apply quantifiers to part of your regex but does not capture/assign an ID.\nFor example, repeating 1-3 digits and a period 3 times can be done like this: /(?:\\d{1,3}\\.){3}\\d{1,3}/", SubType = "Common Tokens", Type = "Group Constructs" },
            new ReferenceItem() { Title = "Capture everything enclosed", Pattern = "(...)", ExamplePattern = "match and (capture )+", ExampleString = "match and capture capture ?", Description = "Isolates part of the full match to be later referred to by ID within the regex or the matches array. IDs start at 1.\nA common misconception is that repeating a capture group would create separate IDs for each time it matches. If that functionality is needed, one has to rely on the global (/g) flag instead. For example: /each (word)/g", SubType = "Common Tokens", Type = "Group Constructs" },
            new ReferenceItem() { Title = "Atomic group (non-capturing)", Pattern = "(?>...)", ExamplePattern = "(?>.+)@", ExampleString = "this line is matched/consumed to the end by .+ and is not allowed to backtrack to find @.", Description = "Matches the longest possible substring in the group and doesn't allow later backtracking to reevaluate the group. It is not a capturing group.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Duplicate/reset subpattern group number", Pattern = "(?|...)", ExamplePattern = "(?|(candy)|(kiss)|(berry))", ExampleString = "A candy, kiss, or even a berry is delicious.", Description = "Does not allow the capture group ID to be incremented for all enclosed capture groups.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Comment group", Pattern = "<?#...)", ExamplePattern = "Not(?# .* <-- that should match all)", ExampleString = "Nothing else matches", Description = "Any text appearing in this group is ignored in the regex.\nAnother option is enabling the x flag to allow `# comments` but it will also cause the regex engine to ignore space characters. To match space characters you have to escape them: /\\ /.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Named capturing group", Pattern = "(?'name'...)", ExamplePattern = "(?'name'Sally)", ExampleString = "Call me Sally", Description = "This capturing group can be referred to using the given name instead of a number. Alternative notation for (?<name>...) or (?P<name>...).", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Named capturing group", Pattern = "(?<name>...)", ExamplePattern = "(?<name>Sally)", ExampleString = "Call me Sally", Description = "This capturing group can be referred to using the given name instead of a number. Alternative notation for (?'name'...) or (?P<name>...).", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Named capturing group", Pattern = "(?P<name>...)", ExamplePattern = "(?P<name>Sally)", ExampleString = "Call me Sally", Description = "This capturing group can be referred to using the given name instead of a number. Alternative notation for (?<name>...) and (?'name'...) when using a PCRE flavor.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Inlin modifiers", Pattern = "(?imsxUJnxx)", ExamplePattern = "a(?i)a", ExampleString = "aA Aa aa AA", Description = "These flag modifiers act on the whole expression. You can also unset flags using a minus sign: (?-i), and can combine setting and unsetting flags. (?s-i) would set the single line flag and unset case insensitive.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Localized inline modifiers", Pattern = "(?imsxUJnxx:...)", ExamplePattern = "(a)(?i:b+)(c)", ExampleString = "aBbBc", Description = "These flag modifiers act on the enclosed expression only. Equivalent to (?:(?imsxUJnxx)...)\nYou can also unset flags using a minus sign: (?-i), and can combine enabling and disabling flags.For example: (? s-i) would set enable single line and disable case insensitive.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Conditional statement", Pattern = "(?(1)yes|no)", ExamplePattern = "(A candy)?(?(1) is true| is false)", ExampleString = "A candy is true is false.", Description = "If capturing group 1 returned a match, the pattern before the alternate | is matched. Otherwise, the pattern after the alternate | is matched.\nIn PCRE a recursion test (R), group name (name), or a relative position (-1) can be used as the conditional. Global flag breaks conditionals as the engine does a second pass over an already matched/consumed string.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Conditional statement", Pattern = "(?(R)yes|no)", ExamplePattern = "<(?:(?(R)\\w++|[^<>]*+)|(?R))*>", ExampleString = "<tag allows=`for nested` <tag> />", Description = "If recursion of the whole pattern is successful, match the pattern before the | otherwise match the pattern after the |.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Recursive conditional statement", Pattern = "(?(R#)yes|no)", ExamplePattern = "( *fun(?(R1)ction|ky))(?1)", ExampleString = "funky function", Description = "`(?R1)` checks if a call to capture group 1 was made, which will return false the first time it is encountered because the regex engine is simply parsing capture group one.\nOnce `(?1)` is called, `(?(R1)true|false)` will return true since capture group 1 was called, and will match `ction`", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Conditional statement", Pattern = "(?(R&name)yes|no)", ExamplePattern = "(?<sub1> *fun(?(R&sub1)ction|ky))(?&sub1)", ExampleString = "funky function", Description = "In this case `(?(R&sub1)...|...)` checks if a call to `sub1` has been made. The first time the recursive conditional is parsed, the engine is in the process of matching what `sub1` requires, not yet finished. Conditional will return false and match `ky` instead.\nOnce we recursively call `(?&sub1)` the conditional will return true as `(?<sub1>)` finished matching, thus `ction` will match.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Lookahead conditional", Pattern = "(?(?=...)yes|no)", ExamplePattern = "(?(?=is)(is delicious)|(disgusting))", ExampleString = "Candy is delicious or disgusting.", Description = "If the lookahead succeeds, matches the pattern before the vertical bar. Otherwise, matches the pattern after the vertical bar. The lookaround can be negative also. Global flag breaks conditionals.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Lookbehind conditional", Pattern = "(?(?<=...)yes|no)", ExamplePattern = "(?(?<=\\s)(delish)|(ew))", ExampleString = "Is candy delish or ew?", Description = "If the lookbehind succeeds, match the pattern before the vertical bar. Otherwise, matches the pattern after the vertical bar. The lookaround can be negative. Global flag, 'g', breaks conditionals.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Recurse entire pattern", Pattern = "(?R)", ExamplePattern = "\\((?:[^()]|((?R)))+\\)", ExampleString = "(simple) (and(nested)) but (not here", Description = "Recursively match the entire expression. Equivalent to (?0) or \\g<0>.\nNote that (?R) is wrapped in a superfluous capture group to help visually identify its match in the example string.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Recurse first subpattern", Pattern = "(?1)", ExamplePattern = "(capture).+((?1))", ExampleString = "capture my capture again", Description = "Recursively match the first capture group.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Recurse first relative subpattern", Pattern = "(?+1)", ExamplePattern = "(?+1).+(match)", ExampleString = "match if I start with match", Description = "Recurse the first capture group following the current position in the expression. (?+2) is the second capture group, (?-1) is the capture group immediately preceding the current position.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Recurse subpattern `name`", Pattern = "(?&name)", ExamplePattern = "(?&named_group) like (?'named_group'[tb]oys)", ExampleString = "boys like toys.", Description = "Recursively matches the given capture group by name. It does not require that the capture group be defined beforehand.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Match subpattern `name`", Pattern = "(?P=name)", ExamplePattern = "(?P<named_group>cool) (?P=named_group)", ExampleString = "cool cool", Description = "Matches the same text matched by a previously named capture group.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Recurse subpattern called `name`", Pattern = "(?P>name)", ExamplePattern = "((?P>who)) or (?<who>[a-z]+)", ExampleString = "123 or 789", Description = "Recursively matches the given named subpattern or capture group.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Pre-define patterns before using them", Pattern = "(?(DEFINE)...)", ExamplePattern = "(?(DEFINE)(?'letters'[a-z]+))(?P>letters)", ExampleString = "123 letters 123", Description = "The DEFINE group is completely ignored by regex. It gets treated as a var name=`value`, whereas you can recall the specific pattern for use via its name. Multiple patterns can be defined in the same DEFINE group.\n(?(DEFINE)(?'numbers'\\d+)(?'lowercase'[a-z]+)(?'uppercase'[A-Z]+))", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Positive lookahead", Pattern = "(?=...)", ExamplePattern = "foo(?=bar)", ExampleString = "foobar foobarz", Description = "Asserts that the given subpattern can be matched here, without consuming characters", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Negative lookahead", Pattern = "(?!...)", ExamplePattern = "foo(!bar)", ExampleString = "foobar foobarz", Description = "Starting at the current position in the expression, ensures that the given pattern will not match. Does not consume characters.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Positive lookbehind", Pattern = "(?<=...)", ExamplePattern = "(?<=foo)bar", ExampleString = "foobar fuubar", Description = "Ensures that the given pattern will match, ending at the current position in the expression. The pattern must have a fixed width. Does not consume any characters.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Negative lookbehind", Pattern = "(?<!...)", ExamplePattern = "/(?<!not )foo/", ExampleString = "not foo but foo", Description = "Ensures that the given pattern would not match and end at the current position in the expression. The pattern must have a fixed width. Does not consume characters.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Control verb", Pattern = "(*ACCEPT)", ExamplePattern = "Candy.+?great(*ACCEPT).+bad", ExampleString = "Candy tastes great but is bad for your teeth.", Description = "This causes the regex to end successfully, skipping the rest of the pattern.\nIf this token is inside a capturing group, only that capturing group is ended successfully at that particular location, while the parent pattern continues to execute.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Control verb", Pattern = "(*FAIL)", ExamplePattern = "Candy.+?(?:bad(*FAIL)|good)", ExampleString = "Candy is bad\nCandy is good", Description = "Force a matching failure at a specific point in the regex. Equivalent to (*F), and a synonym of (?!).", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Control verb", Pattern = "(*MARK:NAME)", ExamplePattern = "", ExampleString = "", Description = "Used to mark internal engine backtracking. When used in conjunction with the /K modifier (show backtracking control names), pcretest can return the mark together with a successful match. Equivalent to (*:NAME). `NAME` does not need to be unique.\nre> /X(*MARK:A)Y|X(*MARK:B)Z/K\ndata> XY\n0: XY\nMK: A\nXZ\n0: XZ\nMK: B", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Control verb", Pattern = "(*COMMIT)", ExamplePattern = "wo+(*COMMIT)w", ExampleString = "woow woow woot woow", Description = "This verb does not allow regex to continue parsing after a matching failure, even if there are other matching strings ahead, and regardless of how many successful matches are before the failure.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Control verb", Pattern = "(*PRUNE)", ExamplePattern = "(*PRUNE)\\w{4,9} strategy|\\w{4,9} dynamics", ExampleString = "marketing dynamics, marketing strategy", Description = "Causes the regex to exit if it tries to backtrack past (*PRUNE)'s position. This is useful when looking to cut down on backtracking at specific points in the regex. Equivalent to (*PRUNE:NAME).", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Control verb", Pattern = "(*SKIP)", ExamplePattern = "aa(*SKIP)ard\\w+", ExampleString = "aaardvark aaaardvark aaaaardvark aaaaaardvark aaaaaaardvark", Description = "Causes the regex engine to give up on the current match if it tries to backtrack past (*SKIP)'s position. This is useful when looking to cut down on backtracking at specific points in the regex. Equivalent to (*SKIP:NAME).", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Control verb", Pattern = "(*THEN)", ExamplePattern = "^.*?(?(?=2)2|3(*THEN)4)", ExampleString = "35234", Description = "Disallows backtracking past (*THEN)'s position, and gives up matching the current alternation if there's a failure. If instead (*THEN) is used outside of an alternation, it will act like (*PRUNE). Equivalent to (*THEN:NAME).", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Pattern modifier", Pattern = "(*UTF)", ExamplePattern = "", ExampleString = "", Description = "This allows regex to treat the string as UTF, be it 8, 16, or 32.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Pattern modifier", Pattern = "(*UTF8)", ExamplePattern = "", ExampleString = "", Description = "This allows regex to treat the string as UTF-8, specifically.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Pattern modifier", Pattern = "(*UTF16)", ExamplePattern = "", ExampleString = "", Description = "This allows regex to treat the string as UTF-16, specifically.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Pattern modifier", Pattern = "(*UTF32)", ExamplePattern = "", ExampleString = "", Description = "This allows regex to treat the string as UTF-32, specifically.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Pattern modifier", Pattern = "(*UCP)", ExamplePattern = "(*UCP)\\d+(\\w+)", ExampleString = "0٠1١2٢3٣4٤5٥6٦7٨٨9٩hة", Description = "UCP (Unicode Character Properties) makes the PCRE engine extend \\B, \\b, \\D, \\d, \\S, \\s, \\W, \\w, and some POSIX character classes to include unicode characters as well, not just ASCII.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Line break modifier", Pattern = "(*CR)", ExamplePattern = "", ExampleString = "", Description = "Makes it so that only a carriage return character is considered a line break.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Line break modifier", Pattern = "(*LF)", ExamplePattern = "", ExampleString = "", Description = "Makes it so that only a line feed character is considered a line break. Common in UNIX documents.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Line break modifier", Pattern = "(*CRLF)", ExamplePattern = "", ExampleString = "", Description = "Makes it so that only a carriage return character followed by a line feed character is considered a line break. Common in Windows documents.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Line break modifier", Pattern = "(*ANYCRLF)", ExamplePattern = "", ExampleString = "", Description = "Makes it so that either a carriage return character or a line feed character, or the two in sequence are considered a line break.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Line break modifier", Pattern = "(*ANY)", ExamplePattern = "", ExampleString = "", Description = "Makes it so that any unicode newline character or sequence thereof counts as a line break.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Line break modifier", Pattern = "\\R", ExamplePattern = "By default, \\R matches any unicode newline character or sequence thereof. Its behavior can be controlled by newline convention verbs like (*BSR_ANYCRLF) or (*BSR_UNICODE).", ExampleString = "", Description = "", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Line break modifier", Pattern = "(*BSR_ANYCRLF)", ExamplePattern = "", ExampleString = "", Description = "Sets the convention for newline matching to \\r\\n, \\r, or \\n for things like the \\R metacharacter.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Line break modifier", Pattern = "(*BSR_UNICODE)", ExamplePattern = "", ExampleString = "", Description = "This sets the convention for newline matching to any unicode newline character or sequence thereof, for things like the \\R metacharacter.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Regex engine modifier", Pattern = "(*LIMIT_MATCH=x)", ExamplePattern = "", ExampleString = "", Description = "Limits the number of times the regex engine is allowed to call `match()` to `x` times. This user set limit cannot be increased past the compile time value or the default, however it can be restricted.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Regex engine modifier", Pattern = "(*LIMIT_RECURSION=d)", ExamplePattern = "", ExampleString = "", Description = "Limits the number of recursions the engine is allowed to make to `d` times. This user set limit cannot be increased past the compile time value or the default, however it can be restricted.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Regex engine modifier", Pattern = "(*NO_AUTO_POSSESS)", ExamplePattern = "", ExampleString = "", Description = "The PCRE regex engine automatically applies some internal optimizations to regexes to avoid unnecessary backtracking. This modifier will disable that behavior, and thus the engine will backtrack until the previously matching instruction fails to do so.", Type = "Group Constructs"},
            new ReferenceItem() { Title = "Regex engine modifier", Pattern = "(*NO_START_OPT)", ExamplePattern = "", ExampleString = "", Description = "Before even attempting a match, the regex engine makes some checks, such as the length of the string. If it is not long enough to fit the pattern, it will automatically return a no match. This optimization can be disabled by using this modifier.", Type = "Group Constructs"},
            
            //Character Classes//
            new ReferenceItem() { Title = "A single character of: a,b or c", Pattern = "[abc]", ExamplePattern = "[abc]+", ExampleString = "a bb ccc", Description = "Matches either an a, b or c character", SubType = "Common Tokens" },
            new ReferenceItem() { Title = "A character except: a,b or c", Pattern = "[^abc]", ExamplePattern = "[^abc]+", ExampleString = "Anything but abc.", Description = "Matches any character except for an a, b or c.", SubType = "Common Tokens" },
            new ReferenceItem() { Title = "A character in the range: a-z", Pattern = "[a-z]", ExamplePattern = "[a-z]+", ExampleString = "Only a-z", Description = "Matches any characters between a and z, including a and z.", SubType = "Common Tokens" },
            new ReferenceItem() { Title = "A character not in the range: a-z", Pattern = "[^a-z]", ExamplePattern = "[^a-z]+", ExampleString = "Anything but a-z.", Description = "Matches any characters except those in the range a-z.", SubType = "Common Tokens" },
            new ReferenceItem() { Title = "A character in the range: a-z or A-Z", Pattern = "[a-zA-Z]", ExamplePattern = "[a-zA-Z]+", ExampleString = "abc123DEF", Description = "Matches any characters between a-z or A-Z. You can combine as much as you please.", SubType = "Common Tokens" },
            new ReferenceItem() { Title = "Letters and digits", Pattern = "[[:alnum:]]", ExamplePattern = "[[:alnum:]]+", ExampleString = "1st, 2nd, and 3rd.", Description = "An alternate way to match any letter or digit. Equivalent to [A-Za-z0-9]. The double square brackets is not a typo, POSIX notation demands it.", Type = "Character Classes"},
            new ReferenceItem() { Title = "Letters", Pattern = "[[:alpha:]]", ExamplePattern = "[[:alpha:]]+", ExampleString = "hello, there!", Description = "An alternate way to match alphabet letters. Equivalent to [A-Za-z]. The double square brackets is not a typo, POSIX notation demands it.", Type = "Character Classes"},
            new ReferenceItem() { Title = "ASCII codes 0-127", Pattern = "[[:ascii:]]", ExamplePattern = "[[:ascii:]]+", ExampleString = "Any basic latin character. é is not one of them.", Description = "Matches any character in the valid ASCII range. Equivalent to [\\x00-\\x7F]. The double square brackets is not a typo, POSIX notation demands it.", Type = "Character Classes"},
            new ReferenceItem() { Title = "Space or tab only", Pattern = "[[:blank:]]", ExamplePattern = "[[:blank:]]", ExampleString = "a b c", Description = "Matches spaces and tabs (but not newlines). Equivalent to [ \\t]. The double square brackets is not a typo, POSIX notation demands it.", Type = "Character Classes"},
            new ReferenceItem() { Title = "Control characters", Pattern = "[[:cntrl:]]", ExamplePattern = "", ExampleString = "", Description = "Matches characters that are often used to control text presentation, including newlines, null characters, tabs and the escape character. Equivalent to [\\x00-\\x1F\\x7F]. The double square brackets is not a typo, POSIX notation demands it.", Type = "Character Classes"},
            new ReferenceItem() { Title = "Decimal digits", Pattern = "[[:digit:]]", ExamplePattern = "[[:digit:]]", ExampleString = "one: 1, two:2", Description = "Matches decimal digits. Equivalent to [0-9] or \\d. The double square brackets is not a typo, POSIX notation demands it.", Type = "Character Classes"},
            new ReferenceItem() { Title = "Visible characters (not space)", Pattern = "[[:graph:]]", ExamplePattern = "[[:graph:]]+", ExampleString = "A|m0st éverything goes.", Description = "Matches printable, non-whitespace, non-control characters only. Equivalent to [\\x21-\\x7E]. The double square brackets is not a typo, POSIX notation demands it.", Type = "Character Classes"},
            new ReferenceItem() { Title = "Lowercase letters", Pattern = "[[:lower:]]", ExamplePattern = "[[:lower:]]+", ExampleString = "abcDEFghi", Description = "Matches lowercase letters. Equivalent to [a-z]. The double square brackets is not a typo, POSIX notation demands it.", Type = "Character Classes"},
            new ReferenceItem() { Title = "Visible characters", Pattern = "[[:print:]]", ExamplePattern = "[[:print:]]+", ExampleString = "A|m0st éverything goes.", Description = "Matches printable characters, part of the basic latin set, such as letters and spaces, without including control characters. The double square brackets is not a typo, POSIX notation demands it", Type = "Character Classes"},
            new ReferenceItem() { Title = "Visible punctuation characters", Pattern = "[[:punct:]]", ExamplePattern = "[[:punct:]]", ExampleString = "hello, regex user!", Description = "Matches characters that are not whitespace, letters or numbers. The double square brackets is not a typo, POSIX notation demands it.", Type = "Character Classes"},
            new ReferenceItem() { Title = "Whitespace", Pattern = "[[:space:]]", ExamplePattern = "[[:space:]]", ExampleString = "any whitespace character", Description = "Matches whitespace characters. Equivalent to \\s. The double square brackets is not a typo, POSIX notation demands it.", Type = "Character Classes"},
            new ReferenceItem() { Title = "Uppercase letters", Pattern = "[[:upper:]]", ExamplePattern = "[[:upper:]]+", ExampleString = "ABCabcDEF", Description = "Matches uppercase letters. Equivalent to [A-Z]. The double square brackets is not a typo, POSIX notation demands it.", Type = "Character Classes"},
            new ReferenceItem() { Title = "Word characters", Pattern = "[[:word:]]", ExamplePattern = "[[:word:]]+", ExampleString = "any word_ character", Description = "Matches letters, numbers and underscores. Equivalent to \\w or [a-zA-Z0-9_]. The double square brackets is not a typo, POSIX notation demands it.", Type = "Character Classes"},
            new ReferenceItem() { Title = "Hexadecimal digits", Pattern = "[[:xdigit:]]", ExamplePattern = "[[:xdigit:]]+", ExampleString = "hex 123! navy blue for css: #0A0AB5", Description = "Matches hexadecimal digits, case insensitive. Equivalent to [0-9a-fA-F].", Type = "Character Classes"},
            new ReferenceItem() { Title = "Start of word", Pattern = "[[:<:]]", ExamplePattern = "[[:<:]]d", ExampleString = "dot end", Description = "This POSIX equivalent of the \\b (word boundary) is interpreted as \\b(?=\\w)", Type = "Character Classes"},
            new ReferenceItem() { Title = "End of word", Pattern = "[[:>:]]", ExamplePattern = "d[[:>:]]", ExampleString = "dot end", Description = "This POSIX equivalent of the `\\b` word boundary is interpreted as \\b(?<=\\w)", Type = "Character Classes"},
        };
        public static List<ReferenceType> ReferenceTypes = new List<ReferenceType>
        {
            new ReferenceType() { Name = "Common Tokens", IsSubType=true, Icon = "M 12 17 l -5.878 3.59 l 1.598 -6.7 l -5.23 -4.48 l 6.865 -0.55 L 12 2.5 l 2.645 6.36 l 6.866 0.55 l -5.231 4.48 l 1.598 6.7 Z" },
            //new ReferenceType() { Name = "General Tokens", IsSubType=true, Icon = "M 12 22 C 6.477 22 2 17.523 2 12 S 6.477 2 12 2 s 10 4.477 10 10 s -4.477 10 -10 10 Z m 0 -2 a 8 8 0 1 0 0 -16 a 8 8 0 0 0 0 16 Z m 0 -5 a 3 3 0 1 1 0 -6 a 3 3 0 0 1 0 6 Z" },
            new ReferenceType() { Name = "All Tokens", IsSubType=true, Icon = "M 7 3 a 1 1 0 0 0 0 2 h 6 a 1 1 0 1 0 0 -2 H 7 Z M 4 7 a 1 1 0 0 1 1 -1 h 10 a 1 1 0 1 1 0 2 H 5 a 1 1 0 0 1 -1 -1 Z M 2 11 a 2 2 0 0 1 2 -2 h 12 a 2 2 0 0 1 2 2 v 4 a 2 2 0 0 1 -2 2 H 4 a 2 2 0 0 1 -2 -2 v -4 Z" },
            new ReferenceType() { Name = "Full Search Result", Icon = "M18.031 16.617l4.283 4.282-1.415 1.415-4.282-4.283A8.96 8.96 0 0 1 11 20c-4.968 0-9-4.032-9-9s4.032-9 9-9 9 4.032 9 9a8.96 8.96 0 0 1-1.969 5.617zm-2.006-.742A6.977 6.977 0 0 0 18 11c0-3.868-3.133-7-7-7-3.868 0-7 3.132-7 7 0 3.867 3.132 7 7 7a6.977 6.977 0 0 0 4.875-1.975l.15-.15z" },
            new ReferenceType() { Name = "Anchors", Icon = "M13 9.874v10.054c3.619-.453 6.487-3.336 6.938-6.972H17L20.704 7A10.041 10.041 0 0 1 22 11.95C22 17.5 17.523 22 12 22S2 17.5 2 11.95c0-1.8.471-3.489 1.296-4.95L7 12.956H4.062c.451 3.636 3.32 6.519 6.938 6.972V9.874A4.002 4.002 0 0 1 12 2a4 4 0 0 1 1 7.874zM12 8a2 2 0 1 0 0-4 2 2 0 0 0 0 4z" },
            new ReferenceType() { Name = "Meta Sequences", Icon = "M12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2zM7.197 14.682l-2.175 2.174a8.549 8.549 0 0 0 1.818 1.899l.305.223 2.173-2.175a5.527 5.527 0 0 1-1.98-1.883l-.14-.238zm9.606 0a5.527 5.527 0 0 1-1.883 1.98l-.238.14 2.174 2.176a8.549 8.549 0 0 0 1.899-1.818l.223-.304-2.175-2.174zM12 8a4 4 0 1 0 0 8 4 4 0 0 0 0-8zM7.145 5.022a8.549 8.549 0 0 0-1.9 1.818l-.223.305 2.175 2.173a5.527 5.527 0 0 1 1.883-1.98l.238-.14-2.173-2.176zm9.71 0l-2.173 2.175a5.527 5.527 0 0 1 1.98 1.883l.14.238 2.176-2.173a8.549 8.549 0 0 0-1.818-1.9l-.304-.223z" },
            new ReferenceType() { Name = "Quantifiers", Icon = "M8 20v1.932a.5.5 0 0 1-.82.385l-4.12-3.433A.5.5 0 0 1 3.382 18H18a2 2 0 0 0 2-2V8h2v8a4 4 0 0 1-4 4H8zm8-16V2.068a.5.5 0 0 1 .82-.385l4.12 3.433a.5.5 0 0 1-.321.884H6a2 2 0 0 0-2 2v8H2V8a4 4 0 0 1 4-4h10zm-5 4h2v8h-2v-6H9V9l2-1z" },
            new ReferenceType() { Name = "Group Constructs", Icon = "M6.923 21C5.113 18.664 4 15.493 4 12c0-3.493 1.113-6.664 2.923-9h2.014C7.235 5.388 6.2 8.542 6.2 12s1.035 6.612 2.737 9H6.923zm10.151 0H15.06c1.702-2.388 2.737-5.542 2.737-9s-1.035-6.612-2.737-9h2.014c1.81 2.336 2.923 5.507 2.923 9 0 3.493-1.112 6.664-2.923 9z" },
            new ReferenceType() { Name = "Character Classes", Icon = "M9 3v2H6v14h3v2H4V3h5zm6 0h5v18h-5v-2h3V5h-3V3z" },

        };
    }
}
